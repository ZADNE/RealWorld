/*!
 *  @author     Dubsky Tomas
 */
#version 460
#include <RealWorld/constants/tile.glsl>
#include <RealWorld/constants/chunk.glsl>
#include <RealWorld/world/shaders/random.glsl>
#include <RealWorld/world/shaders/simulationPll.glsl>
#include <RealWorld/world/shaders/tileLoadStore.glsl>
#include <RealWorld/world/shaders/TilePropertiesUB.glsl>
#include <RealWorld/world/shaders/WorldDynamicsPC.glsl>
#include <RealWorld/constants/tile_properties/fluidProperties.glsl>

layout (local_size_x = 16,
        local_size_y = 16,
        local_size_z = 1
) in;

ivec2 updateOrderOffset(uint index){
    return ivec2((p_updateOrder >> (index * 2u + 1u)) & 1, (p_updateOrder >> (index * 2u)) & 1);
}

uint invocHash(){
    uint globalIndex = gl_GlobalInvocationID.y * (gl_NumWorkGroups.x * gl_WorkGroupSize.x) + gl_GlobalInvocationID.x;
    return globalIndex ^ p_timeHash;
}

bool probTest1023(uint probability){ return (random() & 1023) < probability; }
bool probTest65535(uint probability){ return (random() & 65535) < probability; }
uvec2 blockRandomVariant(uint blockType){
    return uvec2(blockType, isNonsolidBlock(blockType) ? random() & 15 : 12 + (random() & 3));
}

ivec2 extractVelocity(uint var){
    ivec2 vel = ivec2(var & 0xF, (var >> 4) & 0xF);
    return vel - 7;
}

uint constructVelocity(ivec2 velocity){
    velocity = clamp(velocity + 7, 0, 14);
    return (uint(velocity.x) & 0xF) | (uint(velocity.y & 0xF) << 4);
}

ivec2 randomStateDirection2D(){
    return ivec2(
        bool(g_randomState & 1) ? +1 : -1,
        bool(g_randomState & 2) ? +1 : -1
    );
}
int randomStateToDirection1D(){
    return bool(g_randomState & 1) ? +1 : -1;
}

uint fluidIndex(uint fluid){ return fluid & ~k_firstNonsolidBl; }

void leaningFluidDynamics(uvec4 fluid, ivec2 posIm){
    uvec4 surroundings[3];
    int leaningSide = bool(fluid.BL_V & 1) ? 1 : -1;
    uint fi = fluidIndex(fluid.BL_T);
    //Compute surroundings positions
    ivec2 surrPosIm[3] = {
        imPos(posIm + ivec2(+0, k_primMoveDir[fi])),
        imPos(posIm + ivec2(leaningSide, k_primMoveDir[fi])),
        imPos(posIm + ivec2(leaningSide, 0))
    };
    int first_move = probTest1023(k_primMoveProb[fi]) ? 0 : 2;
    int last_move = probTest1023(k_fluidity[fi]) ? 2 : 0;
    //Fetch surroundings
    for(int i = first_move; i <= last_move; ++i){
        surroundings[i] = tileLoadIm(surrPosIm[i]);
    }
    //Look for a swap
    for(int i = first_move; i <= last_move; ++i){
        const uvec4 n = surroundings[i];//The neighbor
        //If touched the trigger tile and passed probability test
        if (n.BL_T == k_triggerConv[fi].z && probTest1023(k_triggerConv[fi].x)){
            tileStoreIm(posIm, uvec4(blockRandomVariant(k_triggerConv[fi].y), fluid.WL));
            return;
        } else if (isNonsolidBlock(n.BL_T) && n.BL_T != fluid.BL_T){//If can swap
            tileStoreIm(surrPosIm[i], uvec4(fluid.BL, n.WL));
            tileStoreIm(posIm, uvec4(n.BL, fluid.WL));
            return;
        }
    }
    
    if (probTest65535(k_randomConv[fi].x)){//Random conversion 1
        fluid.BL = blockRandomVariant(k_randomConv[fi].y);
    } else if (probTest65535(k_randomConv[fi].z)) {//Random conversion 2
        fluid.BL = blockRandomVariant(k_randomConv[fi].w);
    } else if (last_move == 2) {//If could not move horizontally
        fluid.BL_V ^= 1;//Invert the leaning side
    }
    tileStoreIm(posIm, fluid);
}

void velocityFluidDynamics(uvec4 water, ivec2 posIm){
    ivec2 velocity = extractVelocity(water.y);
    uvec4 tileBelow = tileLoadIm(posIm + ivec2(+0, -1));
    if (tileBelow.BL_T == k_air.BL_T){
        velocity.y -= 1;//bool(random() & 3) ? 0 : 1;
        velocity.x -= sign(velocity.x);//bool(random() & 3) ? 0 : sign(velocity.x);
    } else {
        velocity.x += int(velocity.x == 0) * randomStateToDirection1D() * 5;//Shake my direction
    }
    ivec2 shift = ivec2(greaterThan(abs(velocity), ivec2(random() % 7, random() % 7))) * sign(velocity);
    
    if (shift != ivec2(0, 0)){//If the particle should shift
        ivec2 neighborIm = imPos(posIm + shift);
        uvec4 neighbor = tileLoadIm(neighborIm);
        if (neighbor.BL_T == k_air.BL_T){//Can move
            tileStoreIm(posIm, uvec4(k_air.BL, water.WL));
            tileStoreIm(neighborIm, uvec4(water.BL_T, constructVelocity(velocity), neighbor.WL));
        } else if (neighbor.BL_T == k_waterBl){//Collision with another water particle
            tileStoreIm(posIm, uvec4(neighbor.BL_T, neighbor.y, water.WL));//Swap velocities
            tileStoreIm(neighborIm, uvec4(water.BL_T, constructVelocity(velocity), neighbor.WL));
        } else {//Collision with solid block
            ivec2 newVelocity = abs(velocity.yx) * ivec2(equal(shift, ivec2(0, 0))) * randomStateToDirection1D();
            tileStoreIm(posIm, uvec4(water.BL_T, constructVelocity(newVelocity), water.WL));
        }
    } else {//Do not shift the particle, only add gravity
        tileStoreIm(posIm, uvec4(water.BL_T, constructVelocity(velocity), water.WL));
    }
}

const ivec2 k_neighborhood[] = {
    {-1, +1},     {+0, +1},     {+1, +1},
    {-1, +0},                   {+1, +0},
    {-1, -1},     {+0, -1},     {+1, -1}
};

void leafGrowth(uvec4 tile, uint strength, ivec2 posIm){
    /*for (int i = 0; i < k_neighborhood.length(); i++){
        ivec2 nPosIm = imPos(posIm + k_neighborhood[i]);
        uvec4 n = tileLoad(nPosIm);
        if (n.WL_T == k_air.WL_T){
            tileStoreIm(nPosIm, uvec4(n.BL, k_leafWl, strength - 1));
        }
    }*/
    tileStoreIm(posIm, uvec4(tile.BL, k_leafWl, strength - 1));
}

const float k_2piOver127 = 0.04947390005;

void branchSpawn(uvec4 tile, ivec2 posIm){
    float angle = float(tile.WL_V & 127) * k_2piOver127;
    vec2 dir = vec2(cos(angle), sin(angle));
    ivec2 offset = ivec2(dir * 5.0);
    posIm = imPos(posIm + offset);
    tile = tileLoadIm(posIm);
    tileStoreIm(posIm + offset, uvec4(tile.BL, k_leafWl, 2));
}

void main(){
    g_randomState = invocHash();
    const ivec2 invocOffset = p_globalPosTi
                    + chToTi(ivec2(gl_WorkGroupID.xy))
                    + ivec2(gl_LocalInvocationID.xy) * 4;

    for (uint inGroup = 0; inGroup < 4; inGroup++){
        ivec2 inGroupOffset = updateOrderOffset(inGroup) * 2;
        uint inCoreOrderOffset = (random() & 3) * 4;
        for (uint inCore = 0; inCore < 4; inCore++){
            ivec2 posIm = imPos(invocOffset + inGroupOffset + updateOrderOffset(inCore + inCoreOrderOffset));
            uvec4 tile = tileLoadIm(posIm);
            if (tile.BL_T >= k_waterBl && tile.BL_T <= k_smokeBl){
                leaningFluidDynamics(tile, posIm);
            } else if (tile.BL_T == k_acidBl){
                velocityFluidDynamics(tile, posIm);
            }
            /*if (bool(u_wallProperties[tile.WL_T] & WOODb) && bool(tile.WL_V & 128)){
                branchSpawn(tile, posIm);
            } else if (tile.WL_T == k_leafWl){
                if (tile.WL_V > 0) {
                    leafGrowth(tile, tile.WL_V, posIm);
                } else {
                    tileStoreIm(posIm, uvec4(tile.BL, k_air.WL));
                }
            }*/
        }
        groupMemoryBarrier();
        barrier();
    }
}
