/*!
 *  @author     Dubsky Tomas
 */
#version 460
#include <RealWorld/constants/chunk.glsl>
#include <RealWorld/generation/shaders/generateStructure.glsl>
#include <RealWorld/generation/shaders/vegDistribution.glsl>
#include <RealWorld/world/shaders/random.glsl>
const int BranchSB_BINDING = 5;
#include <RealWorld/vegetation/shaders/BranchSBWithAllocation.glsl>
const int VegPreparationSB_BINDING = 6;
#define VegPreparationSB_ACCESS writeonly
#include <RealWorld/generation/shaders/VegPreparationSB.glsl>

layout (local_size_x = 64,
        local_size_y = 1,
        local_size_z = 1
) in;

const int k_invocOffsetTi = iChunkTi.x / int(gl_WorkGroupSize.x);
const int k_randomOffsetTi = k_invocOffsetTi - 1;

int invocXPosTi(ivec2 chunkTi){
    int basePosTi = chunkTi.x + int(gl_LocalInvocationID.x) * k_invocOffsetTi;
    int randomOffsetTi = int(random()) & k_randomOffsetTi;
    return basePosTi + randomOffsetTi;
}

shared int  s_globalFirstBranchIndex;
shared uint s_vegPrepI;
shared uint s_branchPrepI;

void main(){
    // Init shared vars
    if (gl_LocalInvocationID.x == 0){
        s_vegPrepI = 0;
        s_branchPrepI = 0;
    }
    barrier();

    ivec2 chunkTi = p_chunkTi[gl_WorkGroupID.z];
    g_randomState =
        uint(chunkTi.y << 16 | chunkTi.x) ^
        uint(gl_LocalInvocationID.x * 2713) ^
        uint(p_seed);
    ivec2 pTi = ivec2(invocXPosTi(chunkTi), 0);
    float xPx = tiToPx(pTi.x);
    vec2 biomeClimate = biomeClimate(xPx, p_seed);
    Biome biome = biomeStructure(biomeClimate);
    float horizonPx = horizon(xPx, biome, p_seed).r;
    pTi.y = int(pxToTi(horizonPx));

    uint templateIndex = ~0;
    uint branchThreadOffset;
    uint vegPrepThreadOffset;

    // Gather vegetation of the chunk
    if (pTi.y >= chunkTi.y && pTi.y < (chunkTi.y + iChunkTi.y)) {// If on the horizon
        // Select the vegetation to generate
        VegDistr distr = biomeVegDistr(biomeClimate);
        float rndTemplate = randomFloat() * float(gl_WorkGroupSize.x);
        float probMin = 0.0;
        for (int i = 0; i < k_vegTemplates.length(); ++i){
            float probMax = probMin + distr.genProbability[i];
            templateIndex = (rndTemplate > probMin && rndTemplate <= probMax) ? i : templateIndex;
            probMin = probMax;
        }

        // If some vegetation succeeded the test
        if (templateIndex != ~0){
            vegPrepThreadOffset = atomicAdd(s_vegPrepI, 1);
            const uint branchCount = k_vegTemplates[templateIndex].branchCount;
            branchThreadOffset = atomicAdd(s_branchPrepI, branchCount);
        }
    }
    barrier();

    // Allocate space for all vegetation of the chunk
    if (gl_LocalInvocationID.x == 0){
        if (s_branchPrepI > 0){
            s_globalFirstBranchIndex = allocateBranches(
                s_branchPrepI, tiToCh(chunkTi), p_worldTexSizeCh);
            // Also reserve space in the preparation buffer
            s_vegPrepI = atomicAdd(b_vegPrep.vegDispatchSize.x, s_vegPrepI);
            s_branchPrepI = atomicAdd(b_vegPrep.branchDispatchSize.x, s_branchPrepI);
        } else {
            s_globalFirstBranchIndex = -1; // There is no vegetation in the chunk
        }
    }
    barrier();

    // Prepare vegetation instances
    if (s_globalFirstBranchIndex >= 0){ // If allocation succeeded
        if (templateIndex != ~0){ // If this thread represents a vegetation
            float greenMass = biomeClimate.x + biomeClimate.y;
            b_vegPrep.vegInstances[s_vegPrepI + vegPrepThreadOffset] = VegInstance(
                templateIndex,                                      // templateIndex
                s_globalFirstBranchIndex + branchThreadOffset,      // outputIndex
                random(),                                           // randomSeed
                s_branchPrepI + branchThreadOffset,
                (templateIndex != 2 /*not wheat*/) ? pTi : chunkTi, // rootPosTi
                greenMass * 0.25 + 0.75,                            // sizeFactor
                0.5 * randomFloat() + 0.75                          // angleFactor
            );
        }
    }
}
