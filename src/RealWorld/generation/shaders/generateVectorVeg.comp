/*!
 *  @author     Dubsky Tomas
 */
#version 460
#include <RealWorld/world/shaders/random.glsl>
#include <RealWorld/generation/shaders/generateStructure.glsl>
#include <RealWorld/generation/shaders/vegetation.glsl>
const int VegTemplatesUB_BINDING = 2;
#include <RealWorld/generation/shaders/VegTemplatesUB.glsl>
const int BranchVectorSBWrite_BINDING = 4;
const int BranchVectorSBRead_BINDING = 5;
#include <RealWorld/vegetation/shaders/BranchVectorSB.glsl>
const int VegPreparationSB_BINDING = 6;
#include <RealWorld/generation/shaders/VegPreparationSB.glsl>
#include <RealWorld/generation/shaders/GenerationPC.glsl>

const float k_piHalf = 1.57079632679;
const float k_piQuarter = 0.785398163;

layout (local_size_x = 64,
        local_size_y = 1,
        local_size_z = 1
) in;

shared VegInstance  s_instance;
shared VegTemplate  s_tmplt;

float scaleAngle(float a, float s){
    return fract(a < 0.5 ? a * s : 1.0 - (1.0 - a) * s);
}

void generateTree(){
    if (gl_LocalInvocationID.x < s_tmplt.branchCount){
        // Load and randomize branch template
        Branch b = u_vegTemplateBranches[s_tmplt.branchFirstIndex + gl_LocalInvocationID.x];
        b.relRestAngleNorm = fract(bool(s_instance.randomSeed & 1) ? b.relRestAngleNorm : -b.relRestAngleNorm);
        b.relRestAngleNorm = scaleAngle(b.relRestAngleNorm, s_instance.angleFactor);
        b.lengthTi *= 1.0 + (randomFloat() - 0.5) * s_tmplt.rndLength;
        float randAngleScaler = (gl_LocalInvocationID.x == 0) ? 0.0 : s_tmplt.rndAngle;
        b.relRestAngleNorm = fract(b.relRestAngleNorm + (randomFloat() - 0.5) * randAngleScaler);
        vec2 sizeTi = vec2(b.radiusTi, b.lengthTi) * s_instance.sizeFactor;

        // Write the branch
        uint writeIndex = s_instance.writeIndex + gl_LocalInvocationID.x;
        b_branchesWrite[writeIndex] = Branch(
            b.absPosTi          + s_instance.rootPosTi,
            b.parentIndex       + s_instance.writeIndex,
            b.absAngleNorm,
            b.relRestAngleNorm,
            b.angleVelNorm,
            sizeTi.x,
            sizeTi.y,
            b.density,
            b.stiffness,
            vec2(0.0, 0.0)
        );

        // Write raster generation info
        b_branchInstances[s_instance.branchBaseIndex + gl_LocalInvocationID.x] = BranchInstance(
            uvec2(sizeTi),
            s_instance.templateIndex,
            writeIndex,
            g_randomState
        );
    }
}

const int k_randomOffsetTi = iChunkTi.x - 1;

int invocXPosTi(){
    return p_chunkOffsetTi.x + (int(random()) & k_randomOffsetTi);
}

void generateGrass(){
    ivec2 pTi = ivec2(invocXPosTi(), 0);
    float xPx = tiToPx(pTi.x);
    vec2 biomeClimate = biomeClimate(xPx, p_seed);
    Biome biome = biomeStructure(biomeClimate);
    float horizonPx = horizon(xPx, biome, p_seed).r;
    pTi.y = int(pxToTi(horizonPx));

    bool stemBranch = bool(gl_LocalInvocationID.x & 1);
    
    float angleNorm = stemBranch ? 0.0 : 0.25;
    float randAngleScaler = stemBranch ? s_tmplt.rndAngle : 0.0;
    angleNorm = fract(angleNorm + (randomFloat() - 0.5) * randAngleScaler);
    vec2 sizeTi = stemBranch ? vec2(0.5, 22.0) : vec2(0.0, 0.0);
    sizeTi.y *= 1.0 + (randomFloat() - 0.5) * 0.375;

    // Write the branch
    uint writeIndex = s_instance.writeIndex + gl_LocalInvocationID.x;
    b_branchesWrite[writeIndex] = Branch(
        pTi,
        (gl_LocalInvocationID.x & ~1) + s_instance.writeIndex,
        angleNorm,
        angleNorm,
        0.0,
        sizeTi.x,
        sizeTi.y,
        8.0,
        0.015625,
        vec2(0.0, 0.0)
    );

    // Write raster generation info
    b_branchInstances[s_instance.branchBaseIndex + gl_LocalInvocationID.x] = BranchInstance(
        uvec2(sizeTi),
        s_instance.templateIndex,
        writeIndex,
        g_randomState
    );
}

void main(){
    // Load vegetation instance & template description
    if (gl_LocalInvocationID.x == 0){
        s_instance = b_vegInstances[gl_WorkGroupID.x];
        s_tmplt = k_vegTemplates[s_instance.templateIndex];
    }
    barrier();

    g_randomState = s_instance.randomSeed ^ gl_LocalInvocationID.x * 2713;
    if (s_instance.templateIndex != 2){
        generateTree();
    } else {
        generateGrass();
    }
}
