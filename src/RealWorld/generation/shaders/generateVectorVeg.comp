/*!
 *  @author     Dubsky Tomas
 */
#version 460
#include <RealWorld/constants/chunk.glsl>
#include <RealWorld/world/shaders/random.glsl>
#include <RealWorld/generation/shaders/generateStructure.glsl>
#include <RealWorld/generation/shaders/vegDistribution.glsl>
const int VegTemplatesUB_BINDING = 2;
#include <RealWorld/generation/shaders/VegTemplatesUB.glsl>
const int BranchSB_BINDING = 5;
#include <RealWorld/vegetation/shaders/BranchSB.glsl>
const int VegPreparationSB_BINDING = 6;
#include <RealWorld/generation/shaders/VegPreparationSB.glsl>
#include <RealWorld/generation/shaders/GenerationPC.glsl>

layout (local_size_x = 64,
        local_size_y = 1,
        local_size_z = 1
) in;

shared VegInstance  s_instance;
shared VegTemplate  s_tmplt;

float scaleAngle(float a, float s){
    return fract(a < 0.5 ? a * s : 1.0 - (1.0 - a) * s);
}

void generateTree(){
    if (gl_LocalInvocationID.x < s_tmplt.branchCount){
        // Load and randomize branch template
        Branch b = u_vegTemplates.branches[s_tmplt.branchFirstIndex + gl_LocalInvocationID.x];
        b.relRestAngleNorm = fract(bool(s_instance.randomSeed & 1) ? b.relRestAngleNorm : -b.relRestAngleNorm);
        b.relRestAngleNorm = scaleAngle(b.relRestAngleNorm, s_instance.angleFactor);
        b.lengthTi *= 1.0 + (randomFloat() - 0.5) * s_tmplt.rndLength;
        float randAngleScaler = (gl_LocalInvocationID.x == 0) ? 0.0 : s_tmplt.rndAngle;
        b.relRestAngleNorm = fract(b.relRestAngleNorm + (randomFloat() - 0.5) * randAngleScaler);
        vec2 sizeTi = vec2(b.radiusTi, b.lengthTi) * s_instance.sizeFactor;

        // Write the branch
        uint writeIndex = s_instance.writeIndex + gl_LocalInvocationID.x;
        b_branch.absPosTi[p_branchWriteBuf][writeIndex] = b.absPosTi + s_instance.rootPosTi;
        b_branch.absAngNorm[p_branchWriteBuf][writeIndex] = b.absAngleNorm;
        storeBranchParentOffsetWallType(writeIndex, uint(-b.parentIndexOffset), b.wallType);
        b_branch.relRestAngNorm[writeIndex] = b.relRestAngleNorm;
        b_branch.angVel[writeIndex] = b.angleVelNorm;
        b_branch.radiusTi[writeIndex] = sizeTi.x;
        b_branch.lengthTi[writeIndex] = sizeTi.y;
        b_branch.densityStiffness[writeIndex] = vec2(b.density, b.stiffness);

        // Write raster generation info
        b_vegPrep.branchInstances[s_instance.branchBaseIndex + gl_LocalInvocationID.x] = BranchInstance(
            b.absPosTi,     // offsetTi
            uvec2(sizeTi),  // sizeTi
            b.wallType,     // wallType
            writeIndex,     // writeIndex
            g_randomState   // randomSeed
        );
    }
}

const int k_randomOffsetTi = iChunkTi.x - 1;

int invocXPosTi(){
    return p_chunkOffsetTi.x + (int(random()) & k_randomOffsetTi);
}

void generateGrass(){
    ivec2 pTi = ivec2(invocXPosTi(), 0);
    float xPx = tiToPx(pTi.x);
    vec2 biomeClimate = biomeClimate(xPx, p_seed);
    Biome biome = biomeStructure(biomeClimate);
    float horizonPx = horizon(xPx, biome, p_seed).r;
    pTi.y = int(pxToTi(horizonPx));

    bool stemBranch = bool(gl_LocalInvocationID.x & 1);
    
    float angleNorm = stemBranch ? 0.0 : 0.25;
    float randAngleScaler = stemBranch ? s_tmplt.rndAngle : 0.0;
    angleNorm = fract(angleNorm + (randomFloat() - 0.5) * randAngleScaler);
    vec2 sizeTi = stemBranch ? vec2(0.5, 22.0) : vec2(0.0, 0.0);
    sizeTi.y *= 1.0 + (randomFloat() - 0.5) * 0.375;

    // Write the branch
    uint writeIndex = s_instance.writeIndex + gl_LocalInvocationID.x;
    b_branch.absPosTi[p_branchWriteBuf][writeIndex] = pTi;
    b_branch.absAngNorm[p_branchWriteBuf][writeIndex] = angleNorm;
    storeBranchParentOffsetWallType(writeIndex, gl_LocalInvocationID.x & 1, WHEAT_WL);
    b_branch.relRestAngNorm[writeIndex] = angleNorm;
    b_branch.angVel[writeIndex] = 0.0;
    b_branch.radiusTi[writeIndex] = sizeTi.x;
    b_branch.lengthTi[writeIndex] = sizeTi.y;
    b_branch.densityStiffness[writeIndex] = vec2(8.0, 0.015625);

    // Write raster generation info
    b_vegPrep.branchInstances[s_instance.branchBaseIndex + gl_LocalInvocationID.x] = BranchInstance(
        vec2(0),        // offsetTi
        uvec2(sizeTi),  // sizeTi
        WHEAT_WL,       // wallType
        writeIndex,     // writeIndex
        g_randomState   // randomSeed
    );
}

void main(){
    // Load vegetation instance & template description
    if (gl_LocalInvocationID.x == 0){
        s_instance = b_vegPrep.vegInstances[gl_WorkGroupID.x];
        s_tmplt = k_vegTemplates[s_instance.templateIndex];
    }
    barrier();

    g_randomState = s_instance.randomSeed ^ gl_LocalInvocationID.x * 2713;
    if (s_instance.templateIndex != 2){
        generateTree();
    } else {
        generateGrass();
    }
}
