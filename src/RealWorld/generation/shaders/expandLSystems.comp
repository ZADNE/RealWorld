/*!
 *  @author     Dubsky Tomas
 */
#version 460
#include <RealWorld/constants/chunk.glsl>
#include <RealWorld/world/shaders/random.glsl>
#include <RealWorld/generation/shaders/generateStructure.glsl>
#include <RealWorld/generation/shaders/vegDistribution.glsl>
#include <RealWorld/generation/shaders/generationPll.glsl>
#include <RealWorld/generation/shaders/VegTemplatesUB.glsl>
#define VegPrepSB_ACCESS
#include <RealWorld/generation/shaders/VegPrepSB.glsl>
#include <RealWorld/vegetation/shaders/BranchSB.glsl>
#include <RealWorld/generation/shaders/GenerationPC.glsl>

layout (local_size_x = 64,
        local_size_y = 1,
        local_size_z = 1
) in;

const uint k_maxSentenceLength = 512;

shared VegInstance  s_inst;
shared VegTemplate  s_tmplt;
shared uint         s_symbolCount[2];
shared uint8_t      s_symbols[2][k_maxSentenceLength];
shared uint         s_symbolsOfThread[gl_WorkGroupSize.x];
shared uint         s_branchCount;
shared uint         s_branchI;

// Return index relative to the provided rules or ~0 if no rule was selected
uint probSelectRuleIndex(ProbabilisticRewriteRuleBodies rules){
    uint ruleIndex = ~0;
    float rndRule = randomFloat();
    float probMin = 0.0;
    for (int r = 0; r < rules.bodyCount; ++r){
        float probMax = probMin + u_vegTmplts.ruleProbs[rules.firstIndex + r];
        ruleIndex = (rndRule > probMin && rndRule <= probMax) ? r : ruleIndex;
        probMin = probMax;
    }
    return ruleIndex;
}

void doInclusiveScan(){
    const uint id = gl_LocalInvocationID.x;
    for (int off = 1; off <= gl_WorkGroupSize.x / 2; off *= 2){
        uint my = s_symbolsOfThread[id];
        barrier();
        if (id + off < gl_WorkGroupSize.x) {
            s_symbolsOfThread[id + off] += my;
        }
        barrier();
    }
}

void main(){
    const uint id = gl_LocalInvocationID.x;
    // Load vegetation instance & template description
    if (id == 0){
        s_inst = b_vegPrep.vegInstances[gl_WorkGroupID.x];
        s_tmplt = u_vegTmplts.tmplts[s_inst.templateIndex];
        s_branchCount = 0;
        s_symbolCount[0] = s_tmplt.axiom.count;
    }
    barrier();

    // Initialize by the axiom
    if (id < s_symbolCount[0]){
        s_symbols[0][id] = u_vegTmplts.symbols[s_tmplt.axiom.begin + id];
    }
    barrier();

    // Expand the L-system
    g_randomState = s_inst.randomSeed ^ id * 2713;
    for (uint iter = 0; iter < s_tmplt.iterCount; ++iter) {
        s_symbolCount[(iter + 1) & 1] = 0;
        for (uint wi = 0; wi < s_symbolCount[iter & 1]; wi += gl_WorkGroupSize.x){
            // Select a rule to apply based on probabilities
            uint8_t mySymbol = (wi + id < s_symbolCount[iter & 1])
                               ? s_symbols[iter & 1][wi + id]
                               : uint8_t(255);
            ProbabilisticRewriteRuleBodies rules = s_tmplt.rules[mySymbol];
            uint ruleIndex = (mySymbol < k_rewriteableSymbolCount)
                             ? probSelectRuleIndex(rules)
                             : ~0;

            // Write number of symbols required
            uint mySymbolCount = s_symbolsOfThread[id] =
                (ruleIndex != ~0)
                ? u_vegTmplts.ruleBodies[rules.firstIndex + ruleIndex].count
                : 1;

            // Scan the counts to get displacements
            doInclusiveScan();

            // Write selected rule bodies
            uint displacement = s_symbolCount[(iter + 1) & 1] + 
                                s_symbolsOfThread[id] - mySymbolCount;
            if (ruleIndex != ~0){
                uint begin = u_vegTmplts.ruleBodies[rules.firstIndex + ruleIndex].begin;
                for (uint i = 0; i < mySymbolCount; ++i){
                    s_symbols[(iter + 1) & 1][displacement + i] = 
                        u_vegTmplts.symbols[begin + i];
                }
            } else {
                // Or copy the symbol
                s_symbols[(iter + 1) & 1][displacement] = mySymbol;
            }
            barrier();

            // Update the total number of symbols
            if (id == 0) {
                s_symbolCount[(iter + 1) & 1] += 
                    s_symbolsOfThread[min(gl_WorkGroupSize.x, s_symbolCount[iter & 1] - wi) - 1];
            }
        }
    }
    barrier();

    // Interpret the L-system
    // TODO
    /*if (id == 0){
        uint branchCount = 0;
        for (uint i = 0; i < s_symbolCount[s_tmplt.iterCount & 1]; ++i){
            uint8_t s = s_symbols[s_tmplt.iterCount & 1][i];
            branchCount += (s == 0 || s == 17) ? 1 : 0;
        }
        #extension GL_EXT_debug_printf : require
        debugPrintfEXT("SC: %i, BC: %u\n", s_symbolCount[s_tmplt.iterCount & 1], branchCount);
    }*/
    barrier();

    // Reserve space for branches in the preparation buffer
    if (id == 0){
        s_branchI = atomicAdd(b_vegPrep.branchDispatchSize.x, s_branchCount);
        b_vegPrep.prepIndexOfFirstBranch[gl_WorkGroupID.x] = s_branchI;
        b_vegPrep.vegOffsetWithinChunk[gl_WorkGroupID.x] =
            atomicAdd(b_vegPrep.branchOfChunk[s_inst.chunkIndex], s_branchCount);
    }
    barrier();

    // Output branches to the preparation buffer
    for (uint i = id + s_branchI; i < s_branchCount + s_branchI; i += gl_WorkGroupSize.x){
        /*b_vegPrep.vegIndex[i] = gl_WorkGroupID.x;
        b_vegPrep.absPosTi[i] = pTi;
        b_vegPrep.absAngNorm[i] = angleNorm;
        b_vegPrep.parentOffset15wallType31[i] = packBranchParentOffsetWallType(id & 1, k_wheatWl);
        b_vegPrep.relRestAngNorm[i] = angleNorm;
        b_vegPrep.radiusTi[i] = sizeTi.x;
        b_vegPrep.lengthTi[i] = sizeTi.y;
        b_vegPrep.densityStiffness[i] = vec2(8.0, 0.015625);*/
    }
}
