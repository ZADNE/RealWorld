/*!
 *  @author     Dubsky Tomas
 */
#version 460
#include <RealWorld/constants/chunk.glsl>
#include <RealWorld/world/shaders/random.glsl>
#include <RealWorld/generation/shaders/generateStructure.glsl>
#include <RealWorld/generation/shaders/vegDistribution.glsl>
#include <RealWorld/vegetation/shaders/normAngles.glsl>
#include <RealWorld/generation/shaders/generationPll.glsl>
#include <RealWorld/generation/shaders/VegTemplatesUB.glsl>
#define VegPrepSB_ACCESS
#include <RealWorld/generation/shaders/VegPrepSB.glsl>
#include <RealWorld/vegetation/shaders/BranchSB.glsl>
#include <RealWorld/generation/shaders/GenerationPC.glsl>

layout (local_size_x = 64,
        local_size_y = 1,
        local_size_z = 1
) in;

const uint k_maxSentenceLength = 512;

shared VegInstance  s_inst;
shared VegTemplate  s_tmplt;
shared uint         s_symbolCount[2];
shared uint8_t      s_symbols[2][k_maxSentenceLength];
shared float        s_symbolParams[2][k_maxSentenceLength];
shared uint         s_symbolsOfThread[gl_WorkGroupSize.x];
shared uint         s_chunkSize;
shared uint         s_chunkRemainder;
shared uint         s_branchCount;

struct TurtleState {
    vec2    sizeTi;
    vec2    densityStiffness;
    float   relRestAngNorm;
    uint    parentIndex;
};
shared TurtleState  s_stack[8];

// Return index relative to the provided rules or ~0 if no rule was selected
uint probSelectRuleIndex(ProbabilisticRewriteRuleBodies rules){
    uint ruleIndex = ~0;
    float rndRule = randomFloat();
    float probMin = 0.0;
    for (int r = 0; r < rules.bodyCount; ++r){
        float probMax = probMin + u_vegTmplts.ruleProbs[rules.firstIndex + r];
        ruleIndex = (rndRule > probMin && rndRule <= probMax) ? r : ruleIndex;
        probMin = probMax;
    }
    return ruleIndex;
}

void doInclusiveScan(){
    const uint id = gl_LocalInvocationID.x;
    for (int off = 1; off <= gl_WorkGroupSize.x / 2; off *= 2){
        uint my = s_symbolsOfThread[id];
        barrier();
        if (id + off < gl_WorkGroupSize.x) {
            s_symbolsOfThread[id + off] += my;
        }
        barrier();
    }
}

void emitBranch(
    inout uint outIndex, vec2 posTi, float relRestAngNorm, uint parentOffset,
    uint wallType, vec2 sizeTi, vec2 densityStiffness
){
    b_vegPrep.vegIndex[outIndex] = gl_WorkGroupID.x;
    b_vegPrep.absPosTi[outIndex] = posTi;
    b_vegPrep.absAngNorm[outIndex] = 0.25;
    b_vegPrep.parentOffset15wallType31[outIndex] = packBranchParentOffsetWallType(parentOffset, wallType);
    b_vegPrep.relRestAngNorm[outIndex] = relRestAngNorm;
    b_vegPrep.radiusTi[outIndex] = sizeTi.x;
    b_vegPrep.lengthTi[outIndex] = sizeTi.y;
    b_vegPrep.densityStiffness[outIndex] = densityStiffness;
    outIndex++;
}

void main(){
    const uint id = gl_LocalInvocationID.x;
    // Load vegetation instance & template description
    if (id == 0){
        s_inst = b_vegPrep.vegInstances[gl_WorkGroupID.x];
        s_tmplt = u_vegTmplts.tmplts[s_inst.templateIndex];
        s_symbolCount[0] = s_tmplt.axiom.count;
    }
    barrier();

    // Initialize by the axiom
    if (id < s_symbolCount[0]){
        s_symbols[0][id] = u_vegTmplts.symbols[s_tmplt.axiom.begin + id];
        s_symbolParams[0][id] = u_vegTmplts.symbolParams[s_tmplt.axiom.begin + id];
    }
    barrier();

    // Expand the L-system
    g_randomState = s_inst.randomSeed ^ id * 2713;
    for (uint iter = 0; iter < s_tmplt.iterCount; ++iter) {
        s_symbolCount[(iter + 1) & 1] = 0;
        for (uint wi = 0; wi < s_symbolCount[iter & 1]; wi += gl_WorkGroupSize.x){
            // Select a rule to apply based on probabilities
            uint8_t mySymbol = (wi + id < s_symbolCount[iter & 1])
                               ? s_symbols[iter & 1][wi + id]
                               : uint8_t(255);
            ProbabilisticRewriteRuleBodies rules = s_tmplt.rules[mySymbol];
            uint ruleIndex = (mySymbol < k_rewriteableSymbolCount)
                             ? probSelectRuleIndex(rules)
                             : ~0;

            // Write number of symbols required
            uint mySymbolCount = s_symbolsOfThread[id] =
                (ruleIndex != ~0)
                ? u_vegTmplts.ruleBodies[rules.firstIndex + ruleIndex].count
                : 1;

            // Scan the counts to get displacements
            doInclusiveScan();

            // Write selected rule bodies
            uint displacement = s_symbolCount[(iter + 1) & 1] + 
                                s_symbolsOfThread[id] - mySymbolCount;
            if (ruleIndex != ~0){
                uint begin = u_vegTmplts.ruleBodies[rules.firstIndex + ruleIndex].begin;
                for (uint i = 0; i < mySymbolCount; ++i){
                    s_symbols[(iter + 1) & 1][displacement + i] = 
                        u_vegTmplts.symbols[begin + i];
                    s_symbolParams[(iter + 1) & 1][displacement + i] = 
                        u_vegTmplts.symbolParams[begin + i];
                }
            } else {
                // Or copy the symbol
                s_symbols[(iter + 1) & 1][displacement] = mySymbol;
                s_symbolParams[(iter + 1) & 1][displacement] =
                    (wi + id < s_symbolCount[iter & 1])
                    ? s_symbolParams[iter & 1][wi + id]
                    : 0.0;
            }
            barrier();

            // Update the total number of symbols
            if (id == 0) {
                s_symbolCount[(iter + 1) & 1] += 
                    s_symbolsOfThread[min(gl_WorkGroupSize.x, s_symbolCount[iter & 1] - wi) - 1];
            }
        }
    }
    barrier();

    // Count the number of branches
    if (id == 0){
        uint count = s_symbolCount[s_tmplt.iterCount & 1];
        s_chunkSize = count / gl_WorkGroupSize.x;
        s_chunkRemainder = count % gl_WorkGroupSize.x;
        s_branchCount = 1; // 1 for the root degenerated branch
    }
    barrier();
    {
        uint begin = (id < s_chunkRemainder)
                     ? id * (s_chunkSize + 1)
                     : (id - s_chunkRemainder) * s_chunkSize + s_chunkRemainder * (s_chunkSize + 1);
        uint end = begin + s_chunkSize + ((id < s_chunkRemainder) ? 1 : 0);
        uint branchCount = 0;
        for (uint i = begin; i < end; ++i){
            uint8_t s = s_symbols[s_tmplt.iterCount & 1][i];
            branchCount += (s == k_sBranch || s == k_sStem) ? 1 : 0;
        }
        if (branchCount > 0){
            atomicAdd(s_branchCount, branchCount);
        }
    }
    barrier();

    if (id == 0){
        // Reserve space for branches in the preparation buffer
        uint outIndex = atomicAdd(b_vegPrep.branchDispatchSize.x, s_branchCount);
        b_vegPrep.prepIndexOfFirstBranch[gl_WorkGroupID.x] = outIndex;
        b_vegPrep.vegOffsetWithinChunk[gl_WorkGroupID.x] =
            atomicAdd(b_vegPrep.branchOfChunk[s_inst.chunkIndex], s_branchCount);

        // Initialize turtle state stack
        uint stackDepth = 0;
        s_stack[stackDepth] = TurtleState(
            s_tmplt.initSizeTi,
            s_tmplt.densityStiffness,
            0.0,
            outIndex
        );

        // Emit root branch
        emitBranch(outIndex,
            s_inst.rootPosTi,
            0.0,
            0,
            s_tmplt.wallType,
            vec2(0),
            vec2(0)
        );

        // Interpret the L-system -> output branches to the preparation buffer
        uint symbolCount = s_symbolCount[s_tmplt.iterCount & 1];
        for (uint si = 0; si < symbolCount; ++si){
            uint symbol = s_symbols[s_tmplt.iterCount & 1][si];
            float param = s_symbolParams[s_tmplt.iterCount & 1][si];
            switch (symbol){
            case k_sBranch:
            case k_sStem:
                emitBranch(outIndex,
                    vec2(0),
                    s_stack[stackDepth].relRestAngNorm,
                    outIndex - s_stack[stackDepth].parentIndex,
                    s_tmplt.wallType,
                    s_stack[stackDepth].sizeTi,
                    s_stack[stackDepth].densityStiffness
                );
                s_stack[stackDepth].parentIndex = outIndex - 1;
                s_stack[stackDepth].relRestAngNorm = 0.0;
                s_stack[stackDepth].sizeTi *= s_tmplt.sizeChange;
                s_stack[stackDepth].sizeTi.x =
                    max(s_stack[stackDepth].sizeTi.x, 0.5);
                s_stack[stackDepth].densityStiffness.y *= 0.75;
                break;
            case k_sLeftTurn:
                s_stack[stackDepth].relRestAngNorm =
                    fract(s_stack[stackDepth].relRestAngNorm + param);
                break;
            case k_sRightTurn:
                s_stack[stackDepth].relRestAngNorm =
                    fract(s_stack[stackDepth].relRestAngNorm - param);
                break;
            case k_sPush:
                s_stack[stackDepth + 1] = s_stack[stackDepth];
                stackDepth++;
                break;
            case k_sPop:
                stackDepth--;
                break;
            }
        }
    }
}
