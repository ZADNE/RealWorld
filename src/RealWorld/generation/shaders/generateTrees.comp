/*!
 *  @author     Dubsky Tomas
 */
#version 460
#include <RealWorld/constants/body.glsl>
#include <RealWorld/constants/tree.glsl>
#include <RealWorld/world/shaders/random.glsl>
const int TreeTemplatesUB_BINDING = 2;
#include <RealWorld/generation/shaders/TreeTemplatesUB.glsl>
const int BranchesSBWrite_BINDING = 4;
const int BranchesSBRead_BINDING = 5;
#include <RealWorld/trees/shaders/BranchesSB.glsl>
const int TreePreparationSB_BINDING = 6;
#include <RealWorld/generation/shaders/TreePreparationSB.glsl>
#include <RealWorld/generation/shaders/GenerationPC.glsl>

const float k_piHalf = 1.57079632679;
const float k_piQuarter = 0.785398163;

layout (local_size_x = 64,
        local_size_y = 1,
        local_size_z = 1
) in;

shared TreeDescription s_treeDescr;

float scaleAngle(float a, float s){
    return fract(a < 0.5 ? a * s : 1.0 - (1.0 - a) * s);
}

void main(){
    // Load tree description
    if (gl_LocalInvocationID.x == 0){
        s_treeDescr = b_treeDescriptions[gl_WorkGroupID.x];
    }
    barrier();

    // Load and randomize branch template
    Branch tmplt = u_treeTemplateBranches[s_treeDescr.templateRootIndex + gl_LocalInvocationID.x];
    tmplt.relRestAngleNorm = fract(bool(s_treeDescr.randomSeed & 1) ? tmplt.relRestAngleNorm : -tmplt.relRestAngleNorm);
    tmplt.relRestAngleNorm = scaleAngle(tmplt.relRestAngleNorm, s_treeDescr.angleFactor);
    g_randomState = s_treeDescr.randomSeed ^ gl_LocalInvocationID.x * 2017;

    // Write the branch
    b_branchesWrite[s_treeDescr.writeIndex + gl_LocalInvocationID.x] = Branch(
        tmplt.absPosTi          + s_treeDescr.rootPosTi,
        tmplt.parentIndex       + s_treeDescr.writeIndex,
        tmplt.absAngleNorm,
        tmplt.relRestAngleNorm,
        tmplt.angleVelNorm,
        tmplt.radiusTi          * s_treeDescr.sizeFactor,
        tmplt.lengthTi          * s_treeDescr.sizeFactor,
        tmplt.density,
        tmplt.stiffness,
        vec2(0.0, 0.0)
    );
}
