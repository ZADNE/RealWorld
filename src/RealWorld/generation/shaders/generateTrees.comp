/*!
 *  @author     Dubsky Tomas
 */
#version 460
#include <RealWorld/constants/body.glsl>
#include <RealWorld/constants/tree.glsl>
const int TreeTemplatesUB_BINDING = 2;
#include <RealWorld/generation/shaders/TreeTemplatesUB.glsl>
const int BranchesSBWrite_BINDING = 4;
const int BranchesSBRead_BINDING = 5;
#include <RealWorld/trees/shaders/BranchesSB.glsl>
const int TreePreparationSB_BINDING = 6;
#include <RealWorld/generation/shaders/TreePreparationSB.glsl>
#include <RealWorld/generation/shaders/generateStructure.glsl>

const float k_piHalf = 1.57079632679;
const float k_piQuarter = 0.785398163;

layout( local_size_x = 64,
        local_size_y = 1,
        local_size_z = 1
) in;

shared uint s_rootIndex;

void main(){
    // Calculate the horizon
    float pPx = float(p_chunkOffsetTi.x) * TilePx.x;
    vec2 biomeClimate = biomeClimate(pPx, p_seed);
    Biome biome = biomeStructure(biomeClimate);
    float horizonPx = horizon(pPx, biome, p_seed).r;

    if (gl_LocalInvocationIndex == 0){
        s_rootIndex = atomicAdd(b_branchesHeaderWrite.vertexCount, gl_WorkGroupSize.x);
        if ((s_rootIndex + gl_WorkGroupSize.x) > b_branchesHeaderRead.maxBranchCount) {
            s_rootIndex = ~0;
            atomicAdd(b_branchesHeaderWrite.vertexCount, uint(-gl_WorkGroupSize.x));
        }
    }
    barrier();
    if (s_rootIndex == ~0) return;

    uint writeIndex = s_rootIndex + gl_LocalInvocationIndex;
    Branch tmplt = u_treeTemplateBranches[gl_LocalInvocationIndex];
    b_branchesWrite[writeIndex] = Branch(
        pxToTi(vec2(pPx, horizonPx)) + tmplt.absPosTi,
        s_rootIndex + tmplt.parentIndex,
        tmplt.absAngleNorm,
        tmplt.relRestAngleNorm,
        tmplt.angleVelNorm,
        tmplt.radiusTi,
        tmplt.lengthTi,
        tmplt.density,
        tmplt.stiffness,
        vec2(0.0, 0.0)
    );
}
