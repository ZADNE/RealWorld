R""(
#line 3

layout(	local_size_x = ACTIVE_CHUNKS_AREA_X,
		local_size_y = ACTIVE_CHUNKS_AREA_Y,
		local_size_z = 1
) in;

ivec2 getActiveChunk(ivec2 pos){
	return activeChunksCh[pos.y * ACTIVE_CHUNKS_AREA_X + pos.x];
}

shared int counter;

void main(){
	//Init
	if (gl_LocalInvocationIndex == 0){
		counter = 0;
	}
	barrier();
	
	//Gather chunks
	const ivec2 posCh = ivec2(gl_LocalInvocationID.xy);
	ivec2 ch00 = getActiveChunk(posCh);
	ivec2 ch01 = getActiveChunk((posCh + ivec2(0, 1)) & ACTIVE_CHUNKS_AREA_MASK);
	ivec2 ch10 = getActiveChunk((posCh + ivec2(1, 0)) & ACTIVE_CHUNKS_AREA_MASK);
	ivec2 ch11 = getActiveChunk((posCh + ivec2(1, 1)) & ACTIVE_CHUNKS_AREA_MASK);
	
	//Test the continuity
	if ((ch00 + ivec2(0, 1)) == ch01 &&
		(ch10 + ivec2(0, 1)) == ch11 && 
		(ch00 + ivec2(1, 0)) == ch10){
		//The update chunk is continous
		int i = atomicAdd(counter, 1);
		updateOffsetTi[i] = posCh * CHUNK_SIZE + CHUNK_SIZE / 2;
	}
	barrier();
	
	//Output the update group size
	if (gl_LocalInvocationIndex == 0){
		dynamicsGroupSize.x = counter;
	}
}

)""