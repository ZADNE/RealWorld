R""(
#line 3
const int TRANSFORM_GROUP_SIZE = 4;

const ivec2 INVOC_DISPLACEMENT = CHUNK_SIZE / TRANSFORM_GROUP_SIZE;

layout(	local_size_x = TRANSFORM_GROUP_SIZE,
		local_size_y = TRANSFORM_GROUP_SIZE,
		local_size_z = 1
) in;

uint invocHash(){
	uint globalIndex = gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_GlobalInvocationID.x;
	return globalIndex ^ timeHash;
}
uint randomState = invocHash();

//Xorshift algorithm by George Marsaglia
uint random(){
	randomState ^= randomState << 13;
	randomState ^= randomState >> 17;
	randomState ^= randomState << 5;
	return randomState;
}

uvec2 random2(){
	return uvec2(random(), random());
}

const ivec2 OFFSETS[] = {
				{-1, +2},	{+0, +2},	{+1, +2},
	{-2, +1}, 	{-1, +1}, 	{+0, +1}, 	{+1, +1},	{+2, +1},
	{-2, +0}, 	{-1, +0}, 				{+1, +0},	{+2, +0},
	{-2, -1}, 	{-1, -1}, 	{+0, -1}, 	{+1, -1}, 	{+2, -1},
				{-1, -2},	{+0, -2},	{+1, -2}
};

bool edgeRequiredToSpread(uint block_type){
	return isSolidBlock(block_type) ? bool(TRANSFORM[block_type].w) : true;
}

void main(){
	random();
	ivec2 centerTi = updateOffsetTi[gl_WorkGroupID.x] + ivec2(gl_LocalInvocationID.xy) * INVOC_DISPLACEMENT
					+ (ivec2(random(), random()) & (INVOC_DISPLACEMENT - 1));
					
	
	uvec4 tile = tileLoad(centerTi);
	uvec4 propConv = TRANSFORM[tile.BL_T];
	bvec2 edgeTile = bvec2(false, false);
	uint nearbyProperties = 0;
	for(int i = 0; i < OFFSETS.length(); ++i){//Check all neighbors
		uvec4 neighbor = tileLoad(centerTi + OFFSETS[i]);
		//Analyze the neighbor
		nearbyProperties |= TILE_PROPERTIES[neighbor.BL_T];
		edgeTile = edgeTile || isFluidTile(neighbor.TL_T);
	}
	
	bool edgeRequiredToSpread = bool(propConv.z);
	
	//Transform the tile
	bool requiredNearby = (nearbyProperties & propConv.x) == propConv.x;
	bool forbiddenNotNearby = (nearbyProperties & propConv.y) == 0;
	
	if (requiredNearby && forbiddenNotNearby && (!edgeRequiredToSpread || edgeTile.x)){
		tile.BLOCK_TYPE = propConv.w;
	}
	
	bvec2 currentlyInner = lessThan(tile.TILE_VAR, uvec2(12));
	bvec2 isSolid = isSolidTile(tile.TILE_TYPE);
	bvec2 switchToInner = (!edgeTile && !currentlyInner) && isSolid;
	bvec2 switchToOuter = (edgeTile && currentlyInner) && isSolid;
	tile.TILE_VAR =
		mix(tile.TILE_VAR, uvec2(0), switchToInner || switchToOuter)
		+ mix(uvec2(0), random2() % 12, switchToInner)
		+ mix(uvec2(0), random2() % 4 + 12, switchToOuter);
	
	//Store the transformed tile
	tileStore(centerTi, tile);
}

)""