R""(
#line 3
const int TRANSFORM_GROUP_SIZE = 4;

const ivec2 INVOC_DISPLACEMENT = CHUNK_SIZE / TRANSFORM_GROUP_SIZE;

layout(	local_size_x = TRANSFORM_GROUP_SIZE,
		local_size_y = TRANSFORM_GROUP_SIZE,
		local_size_z = 1
) in;

uint invocHash(){
	uint globalIndex = gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_GlobalInvocationID.x;
	return globalIndex ^ timeHash;
}
uint randomState = invocHash();

//Xorshift algorithm by George Marsaglia
uint random(){
	randomState ^= randomState << 13;
	randomState ^= randomState >> 17;
	randomState ^= randomState << 5;
	return randomState;
}

uvec2 random2(){
	return uvec2(random(), random());
}

const ivec2 OFFSETS[] = {
				{-1, +2},	{+0, +2},	{+1, +2},
	{-2, +1}, 	{-1, +1}, 	{+0, +1}, 	{+1, +1},	{+2, +1},
	{-2, +0}, 	{-1, +0}, 				{+1, +0},	{+2, +0},
	{-2, -1}, 	{-1, -1}, 	{+0, -1}, 	{+1, -1}, 	{+2, -1},
				{-1, -2},	{+0, -2},	{+1, -2}
};

uint spreadingBlock(uvec4 tile){
	switch (tile.BLOCK_TYPE){
		case DIRT_BL: return GRASS_BL;
		case STONE_BL: return COLD_STONE_BL;
		default: return 1024;//Unreachable
	}
}

bool edgeRequiredToSpread(uint spreadingBlock){
	switch (spreadingBlock){
		case GRASS_BL: return true;
		default: return false;
	}
}

void main(){
	ivec2 centerTi = updateOffsetTi[gl_WorkGroupID.x] + ivec2(gl_LocalInvocationID.xy) * INVOC_DISPLACEMENT
					+ (ivec2(random(), random()) & (INVOC_DISPLACEMENT - 1));
					
	//Load neighbors
	uvec4 tile = tileLoad(centerTi);
	uvec4 neighbors[OFFSETS.length()];
	for(int i = 0; i < neighbors.length(); ++i){
		neighbors[i] = tileLoad(centerTi + OFFSETS[i]);
	}
	
	//Analyze neighbors
	bool nextToSpreadingBlock = false;
	uint spreadingBlock = spreadingBlock(tile);
	bvec2 edgeTile = bvec2(false, false);
	for(int i = 0; i < neighbors.length(); ++i){
		nextToSpreadingBlock = nextToSpreadingBlock || (neighbors[i].BLOCK_TYPE == spreadingBlock);
		edgeTile = edgeTile || lessThanEqual(neighbors[i].TILE_TYPE, uvec2(LAST_FLUID, AIR_WL));
	}
	bool edgeRequiredToSpread = edgeRequiredToSpread(spreadingBlock);
	
	//Transform the tile
	if (nextToSpreadingBlock && (!edgeRequiredToSpread || edgeTile.x)){
		tile.BLOCK_TYPE = spreadingBlock;
	}
	
	bvec2 currentlyInner = lessThan(tile.TILE_VAR, uvec2(12));
	bvec2 isSolid = greaterThan(tile.TILE_TYPE, uvec2(LAST_FLUID, AIR_WL));
	bvec2 switchToInner = (!edgeTile && !currentlyInner) && isSolid;
	bvec2 switchToOuter = (edgeTile && currentlyInner) && isSolid;
	tile.TILE_VAR =
		mix(tile.TILE_VAR, uvec2(0), switchToInner || switchToOuter)
		+ mix(uvec2(0), random2() % 12, switchToInner)
		+ mix(uvec2(0), random2() % 4 + 12, switchToOuter);
	
	//Store the transformed tile
	//tile.BL_V = (tile.BL_V == 0) ? 12 : 0;
	tileStore(centerTi, tile);
}

)""