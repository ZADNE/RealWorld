R""(
#line 3
layout(	local_size_x = ANALYSIS_GROUP_SIZE,
		local_size_y = ANALYSIS_GROUP_SIZE,
		local_size_z = 1
) in;

layout(binding = TEX_UNIT_WORLD_TEXTURE) uniform usampler2D worldTexture;
layout(binding = TEX_UNIT_BLOCK_LIGHT_ATLAS) uniform sampler2D blockLightTexture;
layout(binding = TEX_UNIT_WALL_LIGHT_ATLAS) uniform sampler2D wallLightTexture;
layout(binding = IMG_UNIT_LIGHT, rgba8) uniform restrict writeonly image2D lightImage;
layout(binding = IMG_UNIT_TRANSLU, r8) uniform restrict writeonly image2D transluImage;
layout(location = 4) uniform ivec2 botLeftTi;

const float TO_UNIT_SCALE = 1.0 / (LIGHT_SCALE * LIGHT_SCALE);

void main(){
	//Calculate position and init variables
	const ivec2 readBasePosTi = botLeftTi + (ivec2(gl_GlobalInvocationID) << LIGHT_SCALE_BITS);
	vec4 light = vec4(0.0);//RGB = color of the light, A = intensity of the light
	vec4 translu = vec4(0.0);//R = translucency of the unit
	
	//Analyze the thread's area
	for (int y = 0; y < LIGHT_SCALE; y++){
		for (int x = 0; x < LIGHT_SCALE; x++){
			//Fetch the tile
			uvec4 tile = texelFetch(worldTexture, (readBasePosTi + ivec2(x, y)) & worldTexMask, 0);
			//Process its translucency
			bool airBlock = isAirBlock(tile.BLOCK_TYPE);
			translu.r += airBlock ? (205.0/255.0) : (160.0/255.0);
			//Process it as a light source
			vec4 blockLight = texelFetch(blockLightTexture, ivec2(tile.yx), 0);
			vec4 wallLight = texelFetch(wallLightTexture, ivec2(tile.wz), 0);
			vec4 tileLight = airBlock ? wallLight : blockLight;
			light += tileLight;
		}
	}
	//Scale
	light *= TO_UNIT_SCALE;
	imageStore(lightImage, ivec2(gl_GlobalInvocationID), light);
	translu.r *= TO_UNIT_SCALE;
	imageStore(transluImage, ivec2(gl_GlobalInvocationID), translu);
}

)""