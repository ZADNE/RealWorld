R""(
#line 3
const int TRANSFORM_GROUP_SIZE = 4;

const ivec2 INVOC_DISPLACEMENT = CHUNK_SIZE / TRANSFORM_GROUP_SIZE;

layout(	local_size_x = TRANSFORM_GROUP_SIZE,
		local_size_y = TRANSFORM_GROUP_SIZE,
		local_size_z = 1
) in;

layout(location = LOC_TIME_HASH) uniform uint timeHash;

uint invocHash(){
	uint globalIndex = gl_GlobalInvocationID.y * (gl_NumWorkGroups.x * gl_WorkGroupSize.x) + gl_GlobalInvocationID.x;
	return globalIndex ^ timeHash;
}
uint randomState = invocHash();

//Xorshift algorithm by George Marsaglia
uint random(){
	randomState ^= randomState << 13;
	randomState ^= randomState >> 17;
	randomState ^= randomState << 5;
	return randomState;
}

const ivec2 OFFSETS[] = {
	{-1, +0},
	{+0, -1},
	{+1, +0},
	{+0, +1}
};

void main(){
	ivec2 centerTi = ivec2(gl_GlobalInvocationID.xy) * INVOC_DISPLACEMENT
					+ (ivec2(random(), random()) & (INVOC_DISPLACEMENT - 1));
					
	uvec4 tile = tileLoadIm(centerTi);
	uvec4 neighbors[4];
	for(int i = 0; i < neighbors.length(); ++i){
		neighbors[i] = tileLoad(centerTi + OFFSETS[i]);
	}
	
	if (tile.BLOCK_TYPE == DIRT.BLOCK_TYPE && tile.BLOCK_VAR >= 12){
		bool nextToGrass = false;
		for(int i = 0; i < neighbors.length(); ++i){
			nextToGrass = nextToGrass ||  (neighbors[i].BLOCK_TYPE == GRASS.BLOCK_TYPE);
		}
		if (nextToGrass){
			tile.BLOCK_TYPE = GRASS.BLOCK_TYPE;
			tileStoreIm(centerTi, tile);
		}
	}
}

)""