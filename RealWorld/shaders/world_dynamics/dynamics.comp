R""(
#line 3
const int DYN_GROUP_SIZE = 16;

layout(	local_size_x = DYN_GROUP_SIZE,
		local_size_y = DYN_GROUP_SIZE,
		local_size_z = 1
) in;

uint invocHash(){
	uint globalIndex = gl_GlobalInvocationID.y * (gl_NumWorkGroups.x * gl_WorkGroupSize.x) + gl_GlobalInvocationID.x;
	return globalIndex ^ timeHash;
}
uint randomState = invocHash();

//Xorshift algorithm by George Marsaglia
uint random(){
	randomState ^= randomState << 13;
	randomState ^= randomState >> 17;
	randomState ^= randomState << 5;
	return randomState;
}

ivec2 extractVelocity(uint var){
	ivec2 vel = ivec2(var & 0xF, (var >> 4) & 0xF);
	return vel - 7;
}

uint constructVelocity(ivec2 velocity){
	velocity = clamp(velocity + 7, 0, 14);
	return (uint(velocity.x) & 0xF) | (uint(velocity.y & 0xF) << 4);
}

ivec2 randomStateDirection2D(){
	return ivec2(
		bool(randomState & 1) ? +1 : -1,
		bool(randomState & 2) ? +1 : -1
	);
}
int randomStateToDirection1D(){
	return bool(randomState & 1) ? +1 : -1;
}

uint FLUIDITY[] = {
	0,
	64,
	1
};

void leaningFluidDynamics(uvec4 fluid, ivec2 posIm){
	uvec4 surroundings[3];
	int leaningSide = bool(fluid.BL_V & 1) ? 1 : -1;
	//Compute surroundings positions
	ivec2 surrPosIm[3] = {
		imPos(posIm + ivec2(+0, -1)),
		imPos(posIm + ivec2(leaningSide, 0)),
		imPos(posIm + ivec2(leaningSide, -1))
	};
	//Fetch surroundings
	int shift = bool((random() & 63) > FLUIDITY[fluid.BL_T]) ? 1 : surroundings.length();
	for(int i = 0; i < shift; ++i){
		surroundings[i] = tileLoadIm(surrPosIm[i]);
	}
	//Look for a swap
	for(int i = 0; i < shift; ++i){
		if (surroundings[i].BL_T == AIR.BL_T){//If can swap
			tileStoreIm(surrPosIm[i], uvec4(fluid.BL, surroundings[i].WL));
			tileStoreIm(posIm, uvec4(AIR.BL, fluid.WL));
			return;
		}
	}
	//Could not swap - change the leaning side
	if (shift != 1){
		fluid.BL_V ^= 1;
		tileStoreIm(posIm, fluid);
	}
}

void velocityFluidDynamics(uvec4 water, ivec2 posIm){
	ivec2 velocity = extractVelocity(water.y);
	uvec4 tileBelow = tileLoadIm(posIm + ivec2(+0, -1));
	if (tileBelow.BL_T == AIR.BL_T){
		velocity.y -= 1;//bool(random() & 3) ? 0 : 1;
		velocity.x -= sign(velocity.x);//bool(random() & 3) ? 0 : sign(velocity.x);
	} else {
		velocity.x += int(velocity.x == 0) * randomStateToDirection1D() * 5;//Shake my direction
	}
	ivec2 shift = ivec2(greaterThan(abs(velocity), ivec2(random() % 7, random() % 7))) * sign(velocity);
	
	if (shift != ivec2(0, 0)){//If the particle should shift
		ivec2 neighborIm = imPos(posIm + shift);
		uvec4 neighbor = tileLoadIm(neighborIm);
		if (neighbor.BL_T == AIR.BL_T){//Can move
			tileStoreIm(posIm, uvec4(AIR.BL, water.WL));
			tileStoreIm(neighborIm, uvec4(water.BL_T, constructVelocity(velocity), neighbor.WL));
		} else if (neighbor.BL_T == WATER.BL_T){//Collision with another water particle
			tileStoreIm(posIm, uvec4(neighbor.BL_T, neighbor.y, water.WL));//Swap velocities
			tileStoreIm(neighborIm, uvec4(water.BL_T, constructVelocity(velocity), neighbor.WL));
		} else {//Collision with solid block
			ivec2 newVelocity = abs(velocity.yx) * ivec2(equal(shift, ivec2(0, 0))) * randomStateToDirection1D();
			tileStoreIm(posIm, uvec4(water.BL_T, constructVelocity(newVelocity), water.WL));
		}
	} else {//Do not shift the particle, only add gravity
		tileStoreIm(posIm, uvec4(water.BL_T, constructVelocity(velocity), water.WL));
	}
}

void main(){
	const ivec2 invocOffset = globalPosTi
					+ ivec2(gl_WorkGroupID.xy) * CHUNK_SIZE
					+ ivec2(gl_LocalInvocationID.xy) * 4;
	
	for (uint inGroup = 0; inGroup < 4; inGroup++){
		ivec2 inGroupOffset = updateOrder[inGroup] * 2;
		uint inQuadOrderOffset = (random() & 3) * 4;
		for (uint inQuad = 0; inQuad < 4; inQuad++){
			ivec2 posIm = imPos(invocOffset + inGroupOffset + updateOrder[inQuad + inQuadOrderOffset]);
			uvec4 tile = tileLoadIm(posIm);
			/*tile.yw++;
			tile.yw = tile.yw % 16;
			tileStoreIm(posIm, tile);*/
			switch (tile.BLOCK_TYPE){
				case WATER_BL:
				case LAVA_BL: leaningFluidDynamics(tile, posIm); break;
				case ACID_BL: velocityFluidDynamics(tile, posIm); break;
			}
		}
		groupMemoryBarrier();
		barrier();
	}
}

)""