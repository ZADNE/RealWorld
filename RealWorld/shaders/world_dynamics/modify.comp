R""(
#line 3
layout(	local_size_x = 16,
		local_size_y = 16,
		local_size_z = 1
) in;

layout(location = LOC_GLOBAL_OFFSET) uniform ivec2 centerTi;
layout(location = LOC_MODIFY_TARGET) uniform uint target;
layout(location = LOC_MODIFY_SHAPE) uniform uint shape;
layout(location = LOC_MODIFY_DIAMETER) uniform float diameter;
layout(location = LOC_MODIFY_TILE) uniform uvec2 toSet;

const uint SET_BLOCK = 0;
const uint SET_WALL = 2;

const uint SQUARE = 0;
const uint DISC = 1;

uint randomState = gl_LocalInvocationIndex;

//Xorshift algorithm by George Marsaglia
uint random(){
	randomState ^= randomState << 13;
	randomState ^= randomState >> 17;
	randomState ^= randomState << 5;
	return randomState;
}

void main(){
	ivec2 offset = ivec2(gl_LocalInvocationID.xy) - ivec2(gl_WorkGroupSize.xy) / 2;
	
	//Construct the shape
	switch (shape){
		case SQUARE:
		if (abs(offset.x) > diameter || abs(offset.y) > diameter){
			return;//Outside of the shape
		}
		break;
		case DISC:
		if (dot(offset, offset) > diameter * diameter){
			return;//Outside of the shape
		}
		break;
	}
	
	//Modify the tile
	ivec2 posIm = imPos(centerTi + offset);
	uvec4 tile = tileLoadIm(posIm);
	switch (target){
		case SET_BLOCK:
		if ((toSet.x == AIR.BL_T) == (tile.BL_T == AIR.BL_T)){
			return;
		}
		tile.BL = toSet;
		break;
		case SET_WALL:
		if ((toSet.x == AIR.WL_T) == (tile.WL_T == AIR.WL_T) == (tile.BL_T <= LAST_FLUID)){
			return;
		}
		tile.WL = toSet;
		break;
	}
	
	//Store the modified tile
	tileStoreIm(posIm, tile);
}

)""