R""(
#line 3
layout(	local_size_x = 16,
		local_size_y = 16,
		local_size_z = 1
) in;

layout(location = LOC_GLOBAL_OFFSET) uniform ivec2 centerTi;
layout(location = LOC_MODIFY_TARGET) uniform uint target;
layout(location = LOC_MODIFY_SHAPE) uniform uint shape;
layout(location = LOC_MODIFY_DIAMETER) uniform float diameter;
layout(location = LOC_MODIFY_TILE) uniform uvec2 tile;

const uint SQUARE = 0;
const uint DISC = 1;

uint invocHash(){
	uint globalIndex = gl_GlobalInvocationID.y * (gl_NumWorkGroups.x * gl_WorkGroupSize.x) + gl_GlobalInvocationID.x;
	return globalIndex;
}
uint randomState = invocHash();

//Xorshift algorithm by George Marsaglia
uint random(){
	randomState ^= randomState << 13;
	randomState ^= randomState >> 17;
	randomState ^= randomState << 5;
	return randomState;
}

void main(){
	ivec2 offset = ivec2(gl_GlobalInvocationID.xy) - ivec2(gl_WorkGroupSize.xy * gl_NumWorkGroups.xy) / 2;
	switch (shape){
		case SQUARE:
		if (abs(offset.x) > diameter || abs(offset.y) > diameter){
			return;
		}
		break;
		case DISC:
		if (dot(offset, offset) > diameter * diameter){
			return;
		}
		break;
	}
	ivec2 posIm = imPos(centerTi + offset);
	uvec4 tile = tileLoadIm(posIm);
	if (tile.BL_T == AIR.BL_T){
		tile.BL = uvec2(WATER.BL_T, random() & 1);
		tileStoreIm(posIm, tile);
	}
}

)""