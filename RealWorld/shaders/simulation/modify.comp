R""(
#line 3
layout(	local_size_x = 16,
		local_size_y = 16,
		local_size_z = 1
) in;

const uint SET_BLOCK = 0;
const uint SET_WALL = 2;

const uint SQUARE = 0;
const uint DISC = 1;

uint randomState;

//Xorshift algorithm by George Marsaglia
uint random(){
	randomState ^= randomState << 13;
	randomState ^= randomState >> 17;
	randomState ^= randomState << 5;
	return randomState;
}

void main(){
	ivec2 offset = ivec2(gl_LocalInvocationID.xy) - ivec2(gl_WorkGroupSize.xy) / 2;
	//Construct the shape
	switch (modifyShape){
		case SQUARE:
		if (abs(offset.x) > modifyDiameter || abs(offset.y) > modifyDiameter){
			return;//Outside of the shape
		}
		break;
		case DISC:
		if (dot(offset, offset) > modifyDiameter * modifyDiameter){
			return;//Outside of the shape
		}
		break;
	}
	//Modify the tile
	ivec2 posIm = imPos(globalPosTi + offset);
	uvec4 tile = tileLoadIm(posIm);
	randomState = (posIm.x * posIm.y) ^ timeHash;
	if (modifyTarget == SET_BLOCK){
		if ((modifySetValue.x == AIR.BL_T) == (tile.BL_T == AIR.BL_T)){
			return;
		}
		tile.BL = modifySetValue.y != 256 ? modifySetValue : uvec2(modifySetValue.x, random() % 12);
	} else {
		if ((modifySetValue.x == AIR.WL_T) == (tile.WL_T == AIR.WL_T) == isFluidBlock(tile.BL_T)){
			return;
		}
		tile.WL = modifySetValue.y != 256 ? modifySetValue : uvec2(modifySetValue.x, random() % 12);
	}
	//Store the modified tile
	tileStoreIm(posIm, tile);
}

)""