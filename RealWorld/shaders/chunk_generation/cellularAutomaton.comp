R""(
#line 3
const int GEN_CA_SIZE = 8;
layout(	local_size_x = 18,
		local_size_y = 18,
		local_size_z = 1
) in;

layout(binding = IMG_UNIT_GEN_TILES, rgba8ui) uniform restrict uimage2D tilesImage;
layout(binding = IMG_UNIT_GEN_MATERIAL, rgba8ui) uniform restrict readonly uimage2D materialImage;

const ivec2 LOW_HIGH[] = {
	{3, 4},
	{4, 5},
	{3, 4},
	{4, 5},
	{3, 4},
	{4, 5},
	{3, 4},
	{4, 5}
};

const ivec2 OFFSETS[] = {
	{-1, +1}, 	{+0, +1}, 	{+1, +1},
	{-1, +0}, 				{+1, +0},
	{-1, -1}, 	{+0, -1}, 	{+1, -1}
};

uvec4 tiles[GEN_CA_SIZE + 2][GEN_CA_SIZE + 2];

void main() {
	//Init tiles
	ivec2 pTi = ivec2(gl_LocalInvocationID .xy) * GEN_CA_SIZE;
	for (int x = 0; x < tiles.length(); x++){
		for (int y = 0; y < tiles[0].length(); y++){
			tiles[x][y] = imageLoad(tilesImage, pTi + ivec2(x - 1, y - 1));
		}
	}
	
	//Output final tiles
	for (int x = 1; x < tiles.length() - 1; x++){
		for (int y = 1; y < tiles[0].length() - 1; y++){
			imageStore(tilesImage, pTi + ivec2(x - 1, y - 1), tiles[x][y]);
		}
	}

	/*uint iterations = imageLoad(tilesImage, 

	uvec4 material = texelFetch(materialTexture, pos, 0);
	ivec2 pos = {gl_FragCoord.xy);
	uint tilesIndex = tilesSelector % 2;
	uvec4 previous = texelFetch(tilesTexture[tilesIndex], pos, 0);
	
	//Check neighbors
	uvec2 neighborsN = uvec2(0, 0);
	for (int i = 0; i < OFFSETS.length(); i++){
		uvec4 neighbor = texelFetch(tilesTexture[tilesIndex], pos + OFFSETS[i], 0);
		neighborsN += mix(uvec2(0, 0}, uvec2(1, 1}, notEqual(neighbor.rb, AIR));
	}
	
	if (previous.g > 0){//If there are more cycles to be done on this tile
		previous.g -= 1;
		uvec4 resultMaterial = uvec4(material.r, previous.gba);
		uvec4 resultAir = uvec4(AIR.r, previous.gba);
		
		if (previous.r == AIR.x){
			result = neighborsN.x > high ? resultMaterial : previous;
		} else {
			result = neighborsN.x < low ? resultAir : previous;
		}
	} else {//No more cycles to be done on this cell
		result = previous;
	}*/
}

)""