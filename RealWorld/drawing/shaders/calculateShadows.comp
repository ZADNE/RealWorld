/*!
 *  @author     Dubsky Tomas
 */
#version 460
#include <RealWorld/constants/light.glsl>

layout( local_size_x = k_calcGroupSize,
        local_size_y = k_calcGroupSize,
        local_size_z = 1
) in;

layout(set = 0, binding = 0)        uniform sampler2D                   u_lightTexture;
layout(set = 0, binding = 1)        uniform sampler2D                   u_transluTexture;
layout(set = 0, binding = 2, rgba8) uniform restrict writeonly image2D  u_shadowsImage;

vec2 g_analysisUvScale = 1.0 / textureSize(u_lightTexture, 0);
const float k_uvOffset = k_lightMaxRangeUn - 0.5;

const float k_piOver16 =    0.19634954084;
const float k_piOver32 =    0.09817477042;
const float k_piOver64 =    0.04908738521;
const float k_piOver128 =   0.0245436926;
const float k_piOver256 =   0.0122718463;

void accumulate(inout vec4 accumulated, vec2 uv){
    vec4 light = texture(u_lightTexture, uv);
    vec4 translu = texture(u_transluTexture, uv).rrrr;
    accumulated = fma(accumulated, translu, light);
}

void ray(inout vec4 light, vec2 centerUv, vec2 dirUv, vec2 firstLast){
    vec2 uv = centerUv + dirUv * firstLast.y;
    for (float i = firstLast.y; i >= firstLast.x; i--){
        accumulate(light, uv);
        uv -= dirUv;
    }
}

vec4 ray1(vec2 centerUv, float a){
    vec4 light = vec4(0.0);
    vec2 dirUv = vec2(cos(a), sin(a)) * g_analysisUvScale;
    ray(light, centerUv, dirUv, vec2(29.0, 32.0));
    return light;
}

vec4 ray2(vec2 centerUv, float a){
    vec4 light = ray1(centerUv, a + k_piOver256) + ray1(centerUv, a - k_piOver256);
    vec2 dirUv = vec2(cos(a), sin(a)) * g_analysisUvScale;
    ray(light, centerUv, dirUv, vec2(15.0, 28.0));
    return light;
}

vec4 ray4(vec2 centerUv, float a){
    vec4 light = ray2(centerUv, a + k_piOver128) + ray2(centerUv, a - k_piOver128);
    vec2 dirUv = vec2(cos(a), sin(a)) * g_analysisUvScale;
    ray(light, centerUv, dirUv, vec2(8.0, 14.0));
    return light;
}

vec4 ray8(vec2 centerUv, float a){
    vec4 light = ray4(centerUv, a + k_piOver64) + ray4(centerUv, a - k_piOver64);
    vec2 dirUv = vec2(cos(a), sin(a)) * g_analysisUvScale;
    ray(light, centerUv, dirUv, vec2(4.0, 7.0));
    return light;
}

vec4 ray16(vec2 centerUv, float a){
    vec4 light = ray8(centerUv, a + k_piOver32) + ray8(centerUv, a - k_piOver32);
    vec2 dirUv = vec2(cos(a), sin(a)) * g_analysisUvScale;
    ray(light, centerUv, dirUv, vec2(2.0, 3.0));
    return light;
}

vec4 ray32(vec2 centerUv, float a){
    vec4 light = ray16(centerUv, a + k_piOver16) + ray16(centerUv, a - k_piOver16);
    vec2 dirUv = vec2(cos(a), sin(a)) * g_analysisUvScale;
    ray(light, centerUv, dirUv, vec2(1.0, 1.0));
    return light;
}

void main(){
    //Calculate position and init variables
    const ivec2 ID = ivec2(gl_GlobalInvocationID);
    vec4 total = vec4(0.0);
    const vec2 centerUv = (vec2(ID) + k_uvOffset) * g_analysisUvScale;
    
    //Eight tree rays, each sums 45 degrees
    for (float a = 0.0; a < 6.2; a += 0.78539816339){
        total += ray32(centerUv, a);
    }
    
    //The center unit
    accumulate(total, centerUv);
    
    vec4 final = vec4(total.rgb, 1.0 - sqrt(total.a));
    imageStore(u_shadowsImage, ID, final);
}
