#version 460
#include <RealWorld/reserved_units/images.glsl>
#include <RealWorld/constants/light.glsl>
#include <RealWorld/drawing/shaders/WorldDrawingPC.glsl>
#include <RealWorld/drawing/shaders/DynamicLightsSSIB.glsl>

layout( local_size_x = 8,
        local_size_y = 2,
        local_size_z = 2
) in;

layout(binding = IMG_UNIT_LIGHT, rgba8) uniform restrict image2D lightImage;

const int TO_UNIT_BITS = LIGHT_SCALE_BITS + 2;
const float TO_UNIT_SCALE = 1.0 / LIGHT_SCALE / TILEPx;

void main(){
    if (gl_GlobalInvocationID.x < lightCount){
        ivec2 lightPosPx = lights[gl_GlobalInvocationID.x].posPx - addLightOffsetPx;
        ivec2 lightPosUn = lightPosPx >> TO_UNIT_BITS;
        ivec2 editPos = lightPosUn + ivec2(gl_LocalInvocationID.yz);
        bvec2 lowerClip = greaterThanEqual(editPos, ivec2(0));
        bvec2 upperClip = lessThan(editPos, imageSize(lightImage));
        if (all(bvec4(lowerClip, upperClip))){//If inside the light image
            vec4 editCol = imageLoad(lightImage, editPos);
            vec4 lightCol = unpackUnorm4x8(lights[gl_GlobalInvocationID.x].col);
            vec2 f = fract(lightPosPx * TO_UNIT_SCALE + vec2(gl_LocalInvocationID.yz));
            vec2 diff = vec2(1.0) - abs(f - vec2(gl_LocalInvocationID.yz));
            editCol += lightCol * diff.x * diff.y;
            imageStore(lightImage, editPos, editCol);
        }
    }
}
