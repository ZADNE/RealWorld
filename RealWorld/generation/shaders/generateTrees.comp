/*!
 *  @author     Dubsky Tomas
 */
#version 460
#include <RealWorld/constants/body.glsl>
#include <RealWorld/constants/tree.glsl>
const int BranchesSBWrite_BINDING = 4;
const int BranchesSBRead_BINDING = 5;
#include <RealWorld/world/shaders/BranchesSB.glsl>
#include <RealWorld/generation/shaders/generateStructure.glsl>

const float k_piHalf = 1.57079632679;
const float k_piQuarter = 0.785398163;

layout( local_size_x = 8,
        local_size_y = 1,
        local_size_z = 1
) in;

void main(){
    // Calculate the horizon
    float pPx = float(p_chunkOffsetTi.x - int(gl_LocalInvocationIndex) * 9) * TilePx.x;
    vec2 biomeClimate = biomeClimate(pPx, p_seed);
    Biome biome = biomeStructure(biomeClimate);
    float horizonPx = horizon(pPx, biome, p_seed).r;
    int horizonTi = int(pxToTi(horizonPx));
    if (horizonTi < p_chunkOffsetTi.y || horizonTi >= (p_chunkOffsetTi.y + iChunkTi.y)) {
        // The chunk is not on the horizon -> do not generate any trees
        return;
    }

    uint index = atomicAdd(b_branchesHeaderWrite.vertexCount, 4) / 4;
    if (index < b_branchesHeaderRead.maxBranchCount) {
        b_branchesWrite[index] = Branch(
            pxToTi(vec2(pPx, horizonPx)),
            index,
            packUnorm4x8(vec4(0.25, 0.25, 0.0, 0.0)),
            2.0,
            20.0,
            1.0,
            1.0
        );
    } else {
        atomicAdd(b_branchesHeaderWrite.vertexCount, uint(-4));
    }
}
