#version 460
#include <RealWorld/constants/tile.glsl>
#include <RealWorld/constants/generation.glsl>
#include <RealWorld/generation/shaders/GenerationPC.glsl>

layout( local_size_x = GEN_CS_GROUP_SIZE,
        local_size_y = GEN_CS_GROUP_SIZE,
        local_size_z = 1
) in;

layout(binding = 0, rgba8ui) uniform restrict           uimage2DArray tilesImage;
layout(binding = 1, rgba8ui) uniform restrict readonly  uimage2D materialImage;

const ivec2 NEIGHBORHOOD[] = {
    {-1, +1},     {+0, +1},     {+1, +1},
    {-1, +0},                   {+1, +0},
    {-1, -1},     {+0, -1},     {+1, -1}
};

void main() {
    //Load previous value of the tile
    const uint loadLayer = (storeLayer + 1) & 1;
    const ivec2 pTi = ivec2(gl_GlobalInvocationID.xy);
    uvec4 tile = imageLoad(tilesImage, ivec3(pTi, loadLayer));

    //Examine neighbors
    uint neighborsN = 0u;
    for (int i = 0; i < NEIGHBORHOOD.length(); i++){
        neighborsN += uint(!isAirBlock(imageLoad(tilesImage, ivec3(pTi + NEIGHBORHOOD[i], loadLayer)).BL_T));
    }

    //Determine new tile
    if (tile.BL_T == AIR_BL){
        if (neighborsN > edgeConsolidationPromote){
            //Surrounded air -> promote to material
            tile = uvec4(imageLoad(materialImage, pTi).BL_T, tile.gba);
        }
    } else {
        if (neighborsN < edgeConsolidationReduce){
            //Lonely solid -> reduce to air
            tile = uvec4(AIR.BL_T, tile.gba);
        }
    }

    //Store the new tile
    imageStore(tilesImage, ivec3(pTi, storeLayer), tile);
}
